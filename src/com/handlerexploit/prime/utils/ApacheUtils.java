/*
 * Copyright (c) 2012 Daniel Huckaby Licensed under the Apache License, Version
 * 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
 * or agreed to in writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
package com.handlerexploit.prime.utils;

import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

class ApacheUtils {

    /*
     * Licensed to the Apache Software Foundation (ASF) under one or more
     * contributor license agreements. See the NOTICE file distributed with this
     * work for additional information regarding copyright ownership. The ASF
     * licenses this file to You under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the
     * License. You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable
     * law or agreed to in writing, software distributed under the License is
     * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     * KIND, either express or implied. See the License for the specific
     * language governing permissions and limitations under the License.
     */
    public static class IOUtils {

        /**
         * The default buffer size to use for
         * {@link #copyLarge(InputStream, OutputStream)} and
         * {@link #copyLarge(Reader, Writer)}
         */
        public static final int DEFAULT_BUFFER_SIZE = 1024 * 4;

        /**
         * Unconditionally close an <code>InputStream</code>.
         * <p>
         * Equivalent to {@link InputStream#close()}, except any exceptions will
         * be ignored. This is typically used in finally blocks.
         * <p>
         * Example code:
         * 
         * <pre>
         * byte[] data = new byte[1024];
         * InputStream in = null;
         * try {
         *     in = new FileInputStream(&quot;foo.txt&quot;);
         *     in.read(data);
         *     in.close(); // close errors are handled
         * } catch (Exception e) {
         *     // error handling
         * } finally {
         *     IOUtils.closeQuietly(in);
         * }
         * </pre>
         * 
         * @param input
         *            the InputStream to close, may be null or already closed
         */
        public static void closeQuietly(InputStream input) {
            closeQuietly((Closeable) input);
        }

        /**
         * Unconditionally close an <code>OutputStream</code>.
         * <p>
         * Equivalent to {@link OutputStream#close()}, except any exceptions
         * will be ignored. This is typically used in finally blocks.
         * <p>
         * Example code:
         * 
         * <pre>
         * byte[] data = &quot;Hello, World&quot;.getBytes();
         * 
         * OutputStream out = null;
         * try {
         *     out = new FileOutputStream(&quot;foo.txt&quot;);
         *     out.write(data);
         *     out.close(); // close errors are handled
         * } catch (IOException e) {
         *     // error handling
         * } finally {
         *     IOUtils.closeQuietly(out);
         * }
         * </pre>
         * 
         * @param output
         *            the OutputStream to close, may be null or already closed
         */
        public static void closeQuietly(OutputStream output) {
            closeQuietly((Closeable) output);
        }

        /**
         * Unconditionally close a <code>Closeable</code>.
         * <p>
         * Equivalent to {@link Closeable#close()}, except any exceptions will
         * be ignored. This is typically used in finally blocks.
         * <p>
         * Example code:
         * 
         * <pre>
         * Closeable closeable = null;
         * try {
         *     closeable = new FileReader(&quot;foo.txt&quot;);
         *     // process closeable
         *     closeable.close();
         * } catch (Exception e) {
         *     // error handling
         * } finally {
         *     IOUtils.closeQuietly(closeable);
         * }
         * </pre>
         * 
         * @param closeable
         *            the object to close, may be null or already closed
         * @since Commons IO 2.0
         */
        public static void closeQuietly(Closeable closeable) {
            try {
                if (closeable != null) {
                    closeable.close();
                }
            } catch (IOException ioe) {
                // ignore
            }
        }

        // copy from InputStream
        // -----------------------------------------------------------------------
        /**
         * Copy bytes from an <code>InputStream</code> to an
         * <code>OutputStream</code>.
         * <p>
         * This method buffers the input internally, so there is no need to use
         * a <code>BufferedInputStream</code>.
         * <p>
         * Large streams (over 2GB) will return a bytes copied value of
         * <code>-1</code> after the copy has completed since the correct number
         * of bytes cannot be returned as an int. For large streams use the
         * <code>copyLarge(InputStream, OutputStream)</code> method.
         * 
         * @param input
         *            the <code>InputStream</code> to read from
         * @param output
         *            the <code>OutputStream</code> to write to
         * @return the number of bytes copied, or -1 if &gt; Integer.MAX_VALUE
         * @throws NullPointerException
         *             if the input or output is null
         * @throws IOException
         *             if an I/O error occurs
         * @since Commons IO 1.1
         */
        public static int copy(InputStream input, OutputStream output)
                throws IOException {
            long count = copyLarge(input, output);
            if (count > Integer.MAX_VALUE) {
                return -1;
            }
            return (int) count;
        }

        /**
         * Copy bytes from a large (over 2GB) <code>InputStream</code> to an
         * <code>OutputStream</code>.
         * <p>
         * This method buffers the input internally, so there is no need to use
         * a <code>BufferedInputStream</code>.
         * 
         * @param input
         *            the <code>InputStream</code> to read from
         * @param output
         *            the <code>OutputStream</code> to write to
         * @return the number of bytes copied
         * @throws NullPointerException
         *             if the input or output is null
         * @throws IOException
         *             if an I/O error occurs
         * @since Commons IO 1.3
         */
        private static long copyLarge(InputStream input, OutputStream output)
                throws IOException {
            byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
            long count = 0;
            int n = 0;
            while (-1 != (n = input.read(buffer))) {
                output.write(buffer, 0, n);
                count += n;
            }
            return count;
        }
    }

    /*
     * Licensed to the Apache Software Foundation (ASF) under one or more
     * contributor license agreements. See the NOTICE file distributed with this
     * work for additional information regarding copyright ownership. The ASF
     * licenses this file to You under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance with the
     * License. You may obtain a copy of the License at
     * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable
     * law or agreed to in writing, software distributed under the License is
     * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     * KIND, either express or implied. See the License for the specific
     * language governing permissions and limitations under the License.
     */
    public static class DigestUtils {

        private static final char[] sToDigits = { '0', '1', '2', '3', '4', '5',
                '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
        private static final MessageDigest sSHA256MessageDigest = getDigest("SHA-256");

        /**
         * Calculates the SHA-256 digest and returns the value as a hex string.
         * <p>
         * Throws a <code>RuntimeException</code> on JRE versions prior to
         * 1.4.0.
         * </p>
         * 
         * @param data
         *            Data to digest
         * @return SHA-256 digest as a hex string
         * @since 1.4
         */
        public static String sha256Hex(String data) {
            return new String(
                    encodeHex(sSHA256MessageDigest.digest(getBytesUnchecked(
                            data, "UTF-8"))));
        }

        private static MessageDigest getDigest(String algorithm) {
            try {
                return MessageDigest.getInstance(algorithm);
            } catch (NoSuchAlgorithmException e) {
                throw new RuntimeException(e.getMessage());
            }
        }

        private static char[] encodeHex(byte[] data) {
            int l = data.length;
            char[] out = new char[l << 1];
            // two characters form the hex value.
            for (int i = 0, j = 0; i < l; i++) {
                out[j++] = sToDigits[(0xF0 & data[i]) >>> 4];
                out[j++] = sToDigits[0x0F & data[i]];
            }
            return out;
        }

        private static byte[] getBytesUnchecked(String string,
                String charsetName) {
            if (string == null) {
                return null;
            }
            try {
                return string.getBytes(charsetName);
            } catch (UnsupportedEncodingException e) {
                throw new RuntimeException();
            }
        }
    }
}